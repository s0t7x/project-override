// server/prisma/schema.prisma
// Defines the database schema for ProjectOverride.
// Includes core models plus Guilds, Friends, Quests, and Auctions.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// --- Core User Authentication ---

model User {
  id             String      @id @default(cuid())
  username       String      @unique
  hashedPassword String
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  characters     Character[]
}

// --- Player Characters ---

model Character {
  id             String      @id @default(cuid())
  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  name           String      @unique
  level          Int         @default(1)
  experience     BigInt      @default(0)

  // Currencies
  bytes          BigInt      @default(0)
  hackChips      Int         @default(0)

  // Last known location
  currentRoomInstanceId String?
  positionX      Float?
  positionY      Float?
  positionZ      Float?
  rotationY      Float?

  // Core Stats
  statsJson      Json?       // Example: { "baseMaxHealth": 100, "baseAttack": 10, "baseSpeed": 5 }

  // Inventory & Equipment (Using JSON initially)
  inventoryJson  Json?       // Example: [{ "baseItemId": "sword_01", "quantity": 1, "instanceId": "unique_sword_instance" }, ...]
  equipmentJson  Json?       // Example: { "HAND_PRIMARY": { "baseItemId": "sword_01", ... }, "CHEST": { ... } }

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // --- Relations Added Below ---
  ownedRooms     Room[]      @relation("RoomOwner")
  quests         CharacterQuest[] // Quests this character has accepted/completed
  guildMember    GuildMember?     // Link to guild membership (if any)
  friends        Friendship[] @relation("CharacterFriends") // Friendships initiated by this character
  friendOf       Friendship[] @relation("FriendOfCharacter") // Friendships where this character is the friend
  auctionListings AuctionListing[] @relation("SellerListings") // Listings created by this character
  auctionBids     AuctionListing[] @relation("CurrentBidder") // Listings where this character is the current bidder
  guildOwned      Guild?           @relation("GuildOwnerRelation") // Guild owned by this character (if leader)
}


// --- World Structure: Entities (Templates & Instances) ---

model BaseEntity {
  id                String       @id @default(cuid())
  name              String       @unique
  type              EntityType
  defaultComponents Json

  worldEntities     WorldEntity[]
  baseItems         BaseItem?
}

model WorldEntity {
  id                   String     @id @default(cuid())
  roomId               String
  room                 Room       @relation(fields: [roomId], references: [id], onDelete: Cascade)

  baseEntityId         String
  baseEntity           BaseEntity @relation(fields: [baseEntityId], references: [id])

  positionX            Float
  positionY            Float
  positionZ            Float
  rotationY            Float?

  componentOverridesJson Json?

  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  @@index([roomId])
  @@index([baseEntityId])
}


// --- World Structure: Items (Templates & Instances) ---

model BaseItem {
  id                String       @id @default(cuid())
  baseEntityId      String       @unique
  baseEntity        BaseEntity   @relation(fields: [baseEntityId], references: [id])

  slot              ItemSlot?
  stackable         Boolean     @default(false)
  maxStackSize      Int?

  itemInstances     ItemInstance[]
}

model ItemInstance {
  id                   String   @id @default(cuid())
  baseItemId           String
  baseItem             BaseItem @relation(fields: [baseItemId], references: [id])

  instanceDataJson     Json?       // Example: { "durability": 85, "enchantment": "fire_damage_1" }

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Potential future relations for direct ownership tracking
  // ownerCharacterId     String?
  // ownerGuildId         String?
  // auctionListingId     String?  @unique // If item is currently listed

  // auctionListing  AuctionListing? @relation(fields: [auctionListingId], references: [id]) // Not needed if using snapshot below

  @@index([baseItemId])
}


// --- World Structure: Maps & Rooms (Instances) ---

model World {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  rooms       Room[]
}

model MapData {
  id        String @id @default(cuid())
  name      String @unique
  blockData Json
  rooms     Room[]
}

model Room {
  id              String     @id @default(cuid())
  worldId         String?
  world           World?     @relation(fields: [worldId], references: [id])

  mapDataId       String
  mapData         MapData    @relation(fields: [mapDataId], references: [id])

  ownerCharacterId String?
  ownerCharacter  Character? @relation("RoomOwner", fields: [ownerCharacterId], references: [id])

  name            String
  isPublic        Boolean    @default(true)
  isPlayerOwned   Boolean    @default(false)

  whitelistJson   Json?      // List of character IDs allowed if !isPublic and isPlayerOwned

  entities        WorldEntity[]

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([worldId])
  @@index([mapDataId])
  @@index([ownerCharacterId])
  @@index([isPlayerOwned, isPublic])
}

// --- Social: Guilds ---

model Guild {
  id              String        @id @default(cuid()) // Unique guild ID
  name            String        @unique              // Guild name, must be unique
  tag             String?       @unique              // Optional short tag (e.g., [TAG])
  ownerCharacterId String        @unique              // The Character ID of the guild leader
  ownerCharacter  Character     @relation("GuildOwnerRelation", fields: [ownerCharacterId], references: [id]) // Relation to the owner character

  // Add more guild properties: description, banner URL, bank balance, etc.
  description     String?
  guildBankJson   Json?         // Store guild bank items/currency

  members         GuildMember[] // List of characters in the guild

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model GuildMember {
  id          String    @id @default(cuid()) // Unique membership ID
  guildId     String                        // Foreign key to Guild
  guild       Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade) // Relation back to Guild
  characterId String    @unique               // Foreign key to Character, ensures one guild per character
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade) // Relation back to Character

  rank        GuildRank @default(RECRUIT)   // Member's rank within the guild
  joinedAt    DateTime  @default(now())     // Timestamp when the member joined

  @@index([guildId]) // Index for finding members of a specific guild
}

// --- Social: Friends ---

model Friendship {
  id                  String    @id @default(cuid())   // Unique ID for the friendship record
  // Character who initiated the request or the 'owner' of this specific relation record
  characterId         String
  character           Character @relation("CharacterFriends", fields: [characterId], references: [id], onDelete: Cascade)
  // Character who is the friend in this relation
  friendId            String
  friend              Character @relation("FriendOfCharacter", fields: [friendId], references: [id], onDelete: Cascade)

  status              FriendStatus                   // Current status (PENDING, ACCEPTED, BLOCKED)
  createdAt           DateTime  @default(now())      // Timestamp when the request was initiated/accepted
  updatedAt           DateTime  @updatedAt           // Timestamp when status last changed

  @@unique([characterId, friendId]) // Ensures only one friendship record exists between two characters in one direction
  @@index([friendId])               // Index for finding who has friended a specific character
}


// --- Gameplay: Quests ---

model Quest {
  id              String   @id @default(cuid()) // Unique quest ID
  name            String   @unique              // Quest name (human-readable)
  description     String                        // Detailed quest description
  levelRequirement Int     @default(1)          // Minimum level to accept the quest

  // Store objectives as structured JSON
  // Example: [{ type: "kill", targetBaseEntityId: "goblin", count: 5 }, { type: "collect", targetBaseItemId: "goblin_ear", count: 10 }, { type: "edit", blockType: "stone", count: 3 }, { type: "interact", targetWorldEntityId: "shrine_instance_1" }]
  objectivesJson  Json

  // Store rewards as structured JSON
  // Example: { "experience": 1000, "bytes": 500, "items": [{ "baseItemId": "reward_sword", "quantity": 1 }], "hackChips": 5 }
  rewardsJson     Json

  // Store prerequisite quest IDs as JSON array
  // Example: ["main_quest_part_1", "side_quest_intro"]
  prerequisitesJson Json?

  // Add other quest details: repeatable?, quest chain info, giver NPC relation?

  characterQuests CharacterQuest[]              // Link to character progress records for this quest
}

model CharacterQuest {
  id            String    @id @default(cuid()) // Unique ID for this character's progress on this quest
  characterId   String                        // Foreign key to Character
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade) // Relation back to Character
  questId       String                        // Foreign key to Quest
  quest         Quest     @relation(fields: [questId], references: [id]) // Relation back to Quest

  status        QuestStatus                   // Current status (AVAILABLE, ACTIVE, COMPLETED, etc.)

  // Store current progress towards objectives as JSON
  // Example: { "kill_goblin": 3, "collect_goblin_ear": 7, "edit_stone": 1 }
  progressJson  Json?

  startedAt     DateTime  @default(now())     // Timestamp when the quest was accepted (status became ACTIVE)
  completedAt   DateTime?                     // Timestamp when the quest was completed/rewarded
  updatedAt     DateTime  @updatedAt

  @@unique([characterId, questId]) // Ensure character has only one progress record per quest
  @@index([questId])               // Index for finding all characters working on a specific quest
}

// --- Economy: Auction House ---

model AuctionListing {
  id                 String    @id @default(cuid()) // Unique ID for the auction listing
  sellerCharacterId  String                        // Foreign key to the selling Character
  sellerCharacter    Character @relation("SellerListings", fields: [sellerCharacterId], references: [id], onDelete: Cascade) // Relation back to seller

  // Store a snapshot of the item being sold to prevent issues if the original item changes/is deleted
  // This includes baseItemId and instanceDataJson from the ItemInstance at time of listing.
  itemSnapshotJson   Json

  buyoutPrice        BigInt?                       // Optional immediate buyout price (use BigInt for currency)
  startingBid        BigInt                        // Minimum starting bid (use BigInt)
  currentBid         BigInt?                       // Current highest bid (use BigInt)
  currentBidderId    String?                       // Foreign key to the current highest bidding Character
  currentBidder      Character? @relation("CurrentBidder", fields: [currentBidderId], references: [id], onUpdate: NoAction, onDelete: SetNull) // Relation back to bidder

  expiresAt          DateTime                      // Timestamp when the auction ends
  createdAt          DateTime  @default(now())     // Timestamp when the listing was created
  updatedAt          DateTime  @updatedAt          // Timestamp of last bid or update

  status             AuctionStatus @default(ACTIVE) // Current status of the listing

  @@index([sellerCharacterId]) // Index for finding listings by seller
  @@index([expiresAt])       // Index for finding active/expired listings
  @@index([status])          // Index for querying listings by status
  // Add index on item properties within itemSnapshotJson if your DB supports JSON indexing and you need it.
}


// --- Enums Used in Models ---

enum EntityType {
  PLAYER
  NPC
  MONSTER
  ITEM
  OBJECT
  PROJECTILE
  PORTAL
}

enum ItemSlot {
  HEAD
  CHEST
  LEGS
  FEET
  HAND_PRIMARY
  HAND_SECONDARY
  ACCESSORY1
  ACCESSORY2
}

enum GuildRank {
    LEADER
    OFFICER
    VETERAN
    MEMBER
    RECRUIT
}

enum FriendStatus {
  PENDING_SENT // Request sent, waiting for recipient
  PENDING_RECEIVED // Request received, waiting for local player action
  ACCEPTED        // Both players agreed to be friends
  BLOCKED_BY_YOU  // You blocked this player
  BLOCKED_BY_THEM // This player blocked you (client might just see 'BLOCKED')
}

enum QuestStatus {
  UNAVAILABLE // Prerequisites not met
  AVAILABLE    // Player meets prerequisites but hasn't accepted
  ACTIVE        // Accepted, in progress
  COMPLETED    // Objectives met, potentially awaiting turn-in/reward
  REWARDED      // Turn-in complete, reward given
  FAILED          // Quest failed (if applicable)
}

enum AuctionStatus {
  ACTIVE      // Currently accepting bids
  SOLD        // Sold via buyout or winning bid
  EXPIRED     // Ended with no bids or winning bid not claimed (handle item return logic)
  CANCELLED   // Cancelled by the seller before ending
}